# 主题：进制与编码
## 问题

1. bit, byte, word, dword, qword的区别
2. 什么是原码，反码，补码，符号-数值码。以8bit为例，给出各自表示的数值范围。
3. 十进制转换为二进制编码： 127， （-127），127.375，（-127.375）
4. 设计BCD译码器，输入0~9。采用verilog描述并画出门级电路图。
5. 异步FIFO深度为17，如何设计地址格雷码？

## 解答
1. 什么是bit
   
    自信息：由克劳德·香农提出，是与概率空间中的单一事件或离散随机变量的值相关的信息量的量度。它的定义为：一个随机产生的事件所包含的自信息数量，只与事件发生的概率相关。事件发生的概率越低，在事件真的发生时，接收到的信息中，包含的自信息越大。此外，根据定义，自信息的量度是正的而且是可加的。如果事件 C 是两个独立事件 A 和 B 的交集，那么宣告 C 发生的信息量就等于分别宣告事件 A 和事件 B 的信息量的和：I(A ∩ B)=I(A)+I(B).
    
    所以，考虑以上的性质，就定义了自信息，用 I 表示： 假设事件 x 发生的概率为P（x），则自信息符号定义为：
    
    I（x） = log(1 / p（x））= -log（p（x））。
    
    注意：在以上定义中，没有指定对数的基底。如果以 2 为底，单位是bit。当使用以 e 为底的对数时，单位将是 nat。对于基底为 10 的对数，单位是 hart。
    
    [参考资料](https://www.cnblogs.com/yinheyi/p/6426431.html)
    
    byte是字节，1byte = 8bit 
    word是字， 1word=8byte
    dword是双字也就是double word， 1dword=2word
    qword是四字 1qword=4word
    
2. 原码 ：是指一个二进制数左边加上符号位后所得到的码，且当二进制数大于0时，符号位为0；二进制数小于0时，符号位为1；二进制数等于0时，符号位可以为0或1(+0/-0)。

    反码：是一种在计算机中数的机器码表示。对于单个数值（二进制的0和1）而言，对其进行取反操作就是将0变为1，1变为0。也就是说，若$X_i=1$， 则反码$\overline{X_i}=0$ ; 若$X_i=0$，那么反码$\overline{X_i}=1$。 数值上面一横代表反码。
    
    
    补码： 正数和0的补码就是该数字本身。负数的补码则是将其对应正数按位取反再加1。补码系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式。只要一种加法电路就可以处理各种有号数加法，而且减法可以用一个数加上另一个数的补码来表示，因此只要有加法电路及补码电路即可完成各种有号数加法及减法，在电路设计上相当方便。
    
3. 进制的转换
    1. 十进制转换为二进制，分为整数部分和小数部分
    2. 整数部分
除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数
    3. 小数部分
乘2取整法，即将小数部分乘以2，然后取整数部分，剩下的小数部分继续乘以2，然后取整数部分，剩下的小数部分又乘以2，一直取到小数部分为零为止。如果永远不能为零，就同十进制数的四舍五入一样，按照要求保留多少位小数时，就根据后面一位是0还是1，取舍，如果是零，舍掉，如果是1，向入一位。换句话说就是0舍1入。读数要从前面的整数读到后面的整数

    4. (127)d = (1111111)b
        (-127)d = (1000_0001)b
        (127.375)d = (1111111.011)b
        (-127.375)d = (1000_0001.011)b

4. 我们假设驱动的是一个段式LCD，输出用于控制一个数码管，我们找到一个真值表用来作为假想的外设 ![](C:\Users\cxhy\Desktop\Image.png)

我们可以确定端口信号为

```verilog
module bcd_decoder(
    data_in,
    data_out
    );

    input   [3:0]     data_in;
    output [6:0]     data_out;
    
    wire     [3:0]     data_in;
    wire     [6:0]     data_out;
    reg      [6:0]     data_out_r;
    
    always(*)begin
        data_out_r = 7'b1111111;
        case(A)
            4'b0000: data_out_r = 7'b0111111;
            4'b0001: data_out_r = 7'b0000110;
            4'b0010: data_out_r = 7'b1011011;
            4'b0011: data_out_r = 7'b1001111;
            4'b0100: data_out_r = 7'b1100110;
            4'b0101: data_out_r = 7'b1101101;
            4'b0110: data_out_r = 7'b1111101;
            4'b0111: data_out_r = 7'b0000111;
            4'b1000: data_out_r = 7'b1111111;
            4'b1001: data_out_r = 7'b1101111;
            4'b1010: data_out_r = 7'b1110111;
            4'b1011: data_out_r = 7'b1111100;
            4'b1100: data_out_r = 7'b0111001;
            4'b1101: data_out_r = 7'b1011110;
            4'b1110: data_out_r = 7'b1111001;
            4'b1111: data_out_r = 7'b1110001;
            default: data_out_r = 7'b00000000;
        endcase
    end  
endmodule
```


​        


